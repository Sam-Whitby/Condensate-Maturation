import math
from itertools import compress
from scipy.stats import multinomial
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['figure.dpi'] = 100
from scipy.signal import savgol_filter
plt.rcParams.update({'font.size': 20})
from scipy import signal




def get_bond_lattice(lattice,position,coupling=None,positions_energies_map=None,energies=False):
    x_shape = lattice.shape[0]
    y_shape = lattice.shape[1]
    bond_lattice = np.zeros((2*x_shape, 2*y_shape))
    for coord,value in np.ndenumerate(lattice):

        x = coord[0]
        y = coord[1]
        #plt.text(x,y,value)
        #do the value on right and below
        
        rx = (coord[0]+1)%x_shape
        ly = (coord[1]+1)%y_shape

        right_value = lattice[rx,y]
        lower_value = lattice[x,ly]
        if energies:
            #then don't plot bonds but plot energies
            bond_lattice[2*x+1,2*y] = coupling[value,right_value]*positions_energies_map[position[value,right_value]]
            bond_lattice[2*x,2*y+1] = coupling[value,lower_value]*positions_energies_map[position[value,lower_value]]
            
        else:
            
            bond_lattice[2*x+1,2*y] = position[value,right_value]
            bond_lattice[2*x,2*y+1] = position[value,lower_value]
    return(bond_lattice)




def MoranI(lattice,mean=None):
    
    #need to know where the values are on the lattice.
    #they are located at 2x + 1,2y and at 2y+1,2x.
    L = np.shape(lattice)[0]

    #first calculate mean, which is just the sum divided by the number of non-zero elements   
    N = (0.5*L**2)
    #print(L,W)
    if mean == None:
        mean = np.sum(lattice)/N
    
    std = 0.
    numerator = 0.
    W = 0.
    for x in range(0,L,2):
        
        for y in range(0,L,2):
            site = lattice[x+1,y]
            delta = site - mean
            
            std += delta**2
        
        
            neighbours = [lattice[(x+3)%L,y],
                          lattice[(x-1)%L,y],
                         lattice[x,(y+1)%L],
                          lattice[x,(y-1)%L]] #,lattice[(x+3)%L,y]],
            
            for n in neighbours:
                numerator += delta*(n-mean)
                W += 1
 
    if std == 0:
        return(1)
    
    return((0.5*(N/W)*(numerator/std))) 



class Helper_Functions:
   
    
    def __init__(self,all_snaps,all_energies,all_directions_dicts,coupling_constants_dict,positions_energies_map_dict,particles):
        self.all_snaps = all_snaps
        self.all_energies = all_energies
        self.all_directions_dicts = all_directions_dicts
        self.particles = particles
        self.coupling_constants_dict = coupling_constants_dict
        self.positions_energies_map_dict = positions_energies_map_dict
        
        
        self.neighbours = [np.array([0,0]),np.array([-1,0]),
                               np.array([0,1]),
                               np.array([1,0]),
                               np.array([0,-1])]   #the agreed order (not sure it matters) for MSD cals.
        
        
        
        #we can already calculate the times. This is just 
        
        self.snap_times = np.array(list(self.all_energies[0].keys()))
        
        self.ordered_D = sorted(list(self.all_snaps.keys()))[-1::-1] #just makes sure D will be in the same order for everything
        
        self.L = np.shape(self.all_snaps[0][1][0])[0]
        
        
    def get_MSD(self,every_trace=1):
#not even sure the line below matters which order!

        every_trace = every_trace
        self.MSD = dict()
        for D,add in self.all_directions_dicts.items():

            x = np.zeros_like(add[0:,::every_trace],dtype=object)

            for i in range(0,len(add[0:])):
                trace = add[i][::every_trace]
                xt = np.cumsum([self.neighbours[t] for t in trace],axis=0)

                x[i] = np.sum(xt**2,axis=1)
                
            

            self.MSD[D] = dict(zip([i*(2./(self.particles*every_trace)) for i in range(0,len(add[0]),every_trace)],np.mean(x[1:],axis=0)))
            
    def get_MoransI(self,energies=False):
        self.Morans = dict()
        for D in self.ordered_D: #ordered_D[0:-1]:
            snaps = self.all_snaps[D]
        
            ps,ls,es = snaps



            correlations = [MoranI(get_bond_lattice(ls[k],ps[k],
                                                    self.coupling_constants_dict[D],
                                                    self.positions_energies_map_dict[D],energies=energies),None) for k in self.snap_times]
            self.Morans[D] = correlations
        
    
        
    
        
    def plot(self):
        fig,axs = plt.subplots(4,1) #,sharex=True)
        plt.gcf().set_size_inches(10,15)
        mpl.rcParams['figure.dpi'] = 200

        plt.rcParams.update({'font.size': 20})

        
        max_height = 0
        every=1
        
        for D in self.ordered_D:
            msd = self.MSD[D]
            
            times = np.array(list(msd.keys()))
            tmax = max(times)
            vals = np.array(list(msd.values()))
            max_height = max(max_height,max(vals))
            axs[0].plot(times,vals,lw=3,label='d = ' + str(D))
            
            #plot SG filtered derivative 
            sos = signal.butter(1, 0.02, 'lp', output='sos')
            #plt.plot(msd.keys(),msd.values())
            filtered = signal.sosfilt(sos, np.array(list(msd.values())))
            s = savgol_filter(filtered[::1],50,10,deriv=1,delta=1,mode='interp')
            times = sorted(list(msd.keys()))
            deltat = times[1] - times[0]

            axs[1].plot(list(msd.keys())[::1],(s/deltat),lw=3)
                
            
            
            axs[2].plot(self.snap_times*(2./self.particles),[E/(0.5*4*self.particles) for E in self.all_energies[D].values()],lw=3)
            
            
            axs[3].plot(self.snap_times*(2./self.particles),self.Morans[D],lw=3)
            
        #Do random for Morans plot
        
        ps,ls,es = self.all_snaps[self.ordered_D[0]]
        
        bonds_mask = get_bond_lattice(ls[0],ps[0]) != 0
        bonds = np.array([1,2])
        Boltzmann_bond = np.exp(bonds)/np.sum((np.exp(bonds)))
        random_arrays = [np.multiply(bonds_mask,np.random.choice(bonds,p=Boltzmann_bond,size=(self.L*2,self.L*2))) for t in self.snap_times]
        rcorrelations = [MoranI(random_arrays[k],None) for k in range(0,len(self.snap_times))]
        axs[3].plot(self.snap_times*(2./self.particles),rcorrelations,lw=3,c='black',ls='dashed') 
            
            
        axs[0].plot([0,max_height] ,[0,max_height],c='black',ls='dashed',lw=3)
        
        axs[0].legend()    
          
        axs[0].set_ylabel('$\\langle \mathbf{(x - \mathbf{x}_{0})^{2}} \\rangle $')
        axs[1].set_ylabel('D')
        axs[2].set_ylabel('Energy/n/particle')
        axs[3].set_ylabel('I')
        
        
        
        
    def plot_snaps(self,D_i_values = [0,1]):
        
        sections = 5
        
        fig,axs = plt.subplots(len(D_i_values),sections,figsize=(6,5)) #,tight_layout = True,sharey = True,sharex = True)
        
    #    vmax = np.max([np.max(E) for E in self.energy_snaps.values()])
        vmax = 2
        print("V",vmax)
        cmap = mpl.colors.LinearSegmentedColormap.from_list("", ["black"]+ ["white","red"] )#mpl.colormaps['plasma'].colors[0:256:int(256/2)])

        #self.ordered_D #is a list of all the D values in order
        k = 0 #counts over
        D_values = list(self.all_snaps.values()) #make it a list so can index with i
        for D_i in D_i_values: 
            D = self.ordered_D[D_i]

            snap = D_values[D_i]
            i = 0
            for j in range(0,len(self.snap_times)-1,int(len(self.snap_times)/sections)):
                time = self.snap_times[j]
   
                ps,ls,es = snap

                bond_lattice=get_bond_lattice(ls[time],ps[time])

                im = axs[k,i].matshow(bond_lattice,cmap=cmap,vmin=0,vmax=2,origin='lower')

                axs[k,i].set_aspect('equal')

                if k == 0:
                    axs[k,i].set_title('{0:.2f}'.format(time*(2./self.particles)))
                if j == 0:

                    axs[k,i].set_ylabel('{0:.2f}'.format(D))
                axs[k,i].set_xticks([])
                axs[k,i].set_yticks([])
                
                i+= 1
            k += 1
             
        fig.subplots_adjust(wspace=0, hspace=0.2)
        fig.supxlabel('Time')
        fig.supylabel('Bond Diffusion, d')



        bounds = np.linspace(1, 2, 2)
        norm = mpl.colors.BoundaryNorm(bounds, cmap.N)


        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax,boundaries=bounds,norm=norm)
        cbar_ax.set_yticks(np.array([1,2])-0.5,labels=["n = " + str(n) for n in [1,2]], minor=False)
        
        plt.show()

        
