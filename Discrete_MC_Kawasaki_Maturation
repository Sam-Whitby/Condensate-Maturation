import math
class Kawasaki_Discrete:
   
    
    def __init__(self,beta=1,dimension=1,particles=2,L=5,seed=0,max_x = 0,D=1):
        
        self.dimensions = dimension
        np.random.seed(seed)
        self.max_x = max_x
        self.beta= beta
        self.L = L
        self.counter = 0
        self.initial_bonding_position = 0
        
        radius_2 = int(particles/np.pi)
        #first get the radius
        p = 1
        
         
            
        
        self.particles = particles
        #self.FRAP = False
        self.particle_locations = dict()
        
        
        if self.dimensions == 1:
            self.lattice = np.zeros(self.L,dtype=int)
            self.neighbours = [np.array([-1]),np.array([1])]
            self.neighbour_ids = np.array([0,1])
            
            p = 1  
            while p <= particles:

                self.lattice[p-1] = p
                self.particle_locations[p] = p-1
                p += 1
                    
                    
        elif self.dimensions == 2:
            self.lattice = np.zeros((self.L,self.L),dtype=int)
            self.neighbours = [np.array([-1,0]),
                           np.array([1,0]),
                           np.array([0,1]),
                           np.array([0,-1])]
            self.neighbour_ids = np.array([0,1,2,3])
            
            p = 1
            for coord,site in np.ndenumerate(self.lattice):

                dist = np.array(coord) - self.L/2
                if np.dot(dist,dist) <= radius_2:
                    self.lattice[tuple(coord)] = p
                    self.particle_locations[p] = tuple(coord)
                    p += 1
                    if p == particles:
                        break

            x0,y0 = np.where(self.lattice == 0)       
            while p <= particles:
                r = np.random.randint(len(x0))
                if self.lattice[x0[r],y0[r]] == 0:
                    self.lattice[x0[r],y0[r]] = p
                    self.particle_locations[p] = tuple(coord)
                    p += 1
            
        
            
        else:
            print("ERROR - DIMENSION NOT SUPPORTED")
            return()
        
        
        
        
        
        
        
        
        
        self.unique = 1 + particles
        self.position = np.zeros((self.unique,self.unique),dtype=int)
        
        pairs = self.get_pairs()
        for pair in pairs:
            p1,p2 = pair
            self.position[p1,p2] = 1
            self.position[p2,p1] = 1
       # print("DONE", self.position)
        self.results = dict()
        self.pair_count = dict()
        self.D = D
        self.swaps = dict()
        
        self.lattice_snaps = dict()
        #self.neighbours = np.array([-1,1])
        
        
    def compare_Boltzmann(self):
        
        #two situations - one where bond starts at 1 and one where starts at 0
        
        energies = list(set(self.results.values()))
        
        occurences = [(i,list(self.results.values()).count(i)) for i in energies]
        

        sim_results = dict()
        theoretical_results = dict()

        data = np.array(list(self.results.values()))
        count = len(data)
        arrangements = math.perm(self.L,2)
        if self.L > 2:
            degeneracy_unbonded = math.perm(self.L,1)*math.perm(self.L-3,1)
        else:
            degeneracy_unbonded = 0
        degeneracy_bonded = (arrangements - degeneracy_unbonded)
        print("AUB",arrangements,degeneracy_unbonded,degeneracy_bonded)


        #bonded is 0 or 1
        #unbonded is not all the things that are 0

        for x in set(data):
            print("x=",x,degeneracy_bonded,np.exp(-self.beta*x))
            theoretical_results[x] = degeneracy_bonded*np.exp(-self.beta*x) + (x==0)*degeneracy_unbonded


        theoretical_Z = np.sum(list(theoretical_results.values()))
        theoretical_results = dict(zip(theoretical_results.keys(),(1./theoretical_Z)*np.array(list(theoretical_results.values()))))


        for x in set(data):
            #print("HERE",x,np.exp(-a.beta*x))
            r = np.sum(data == x)/count

            sim_results[x] = r

        sim_Z = np.sum(list(sim_results.values()))
        sim_results = dict(zip(sim_results.keys(),(1./sim_Z)*np.array(list(sim_results.values()))))
        print("ST",sim_results,theoretical_results)
        plt.scatter(theoretical_results.values(),sim_results.values())
         #sim_results.keys()))
        plt.plot(theoretical_results.values(), theoretical_results.values())
        
        
    def draw_energies(self):
        pairs = set()
        for coord,site in np.ndenumerate(self.lattice): #range(0,len(self.lattice)):
            
            #site = self.lattice[i]
            if site == 0: #no need to consider solvent
                continue
            for n in self.neighbours:
                n_coord = (np.array(coord)+n)%self.L
                neighbour = self.lattice[tuple(n_coord)]
                #print("HERE",self.counter,(np.array(coord)+n)%self.L)
                if neighbour != 0:

                    pairs.add((tuple(sorted([site,neighbour])),coord))
        E_matrix = np.zeros((self.L,self.L))
        for info in pairs:
           # print("HERE",info)
            p1,p2 = info[0]
            coord = info[1]
            E = -self.position[p1,p2]*np.sign(p1)*np.sign(p2)
            
            E_matrix[tuple(coord)] += E
        return(E_matrix)
    
    def total_energy(self):
        E = 0
        pairs = self.get_pairs()
        for pair in pairs:
            p1,p2 = pair
        
            E += -self.position[p1,p2]*np.sign(p1)*np.sign(p2)
        
            
        return(E)
        #gets here, means we just need the 
        
        
        return(-E)
    
    def get_pairs(self):
        pairs = set()
        for coord,site in np.ndenumerate(self.lattice): #range(0,len(self.lattice)):
            
            #site = self.lattice[i]
            if site == 0: #no need to consider solvent
                continue
            for n in self.neighbours:
                n_coord = (np.array(coord)+n)%self.L
                neighbour = self.lattice[tuple(n_coord)]
                #print("HERE",self.counter,(np.array(coord)+n)%self.L)
                if neighbour != 0:
                    
                    pairs.add(tuple(sorted([site,neighbour])))
        
        return(pairs)
    
    def update_position(self):
        
        
        #self.difs[self.counter] = len(pairs)
        if len(self.pairs) == 0:
            return()
        
        
        #calculate if diffuses or not
        if np.random.rand() > self.D:
            return()
        
        pair = list(self.pairs)[np.random.randint(len(self.pairs))]
        p1,p2 = pair

        old = np.copy(self.position[p1,p2])
        old_bond_E = -old
       # new = np.random.randint(self.max_x+1)
        dx = np.random.choice([-1,1])
        new = min(max(old + dx,self.initial_bonding_position),self.max_x)
        self.position[p1,p2] = new
        self.position[p2,p1] = new
        new_bond_E = - self.position[p1,p2]
        
        
        new_E = self.E - old_bond_E + new_bond_E # self.total_energy()
        #print("UPDATE",-self.beta*(new_E - self.E))
        
        if np.random.rand() < np.exp(-self.beta*(new_E - self.E)):
            self.E = new_E
        else:
            self.position[p1,p2] = old
            self.position[p2,p1] = old
        return()
        
        
        
    def Kawasaki(self):
        
        #get old stuff copied
        
        #shuffle neighbour ids and pick the first one. Use the rest for site 1. Mirror them (* -1 ) for site 2
        np.random.shuffle(self.neighbour_ids)
        
        direction_id = self.neighbour_ids[0]
        
        #print(self.neighbour_ids,direction_id,self.neighbour_ids)
        
        direction = self.neighbours[direction_id]
        
      #  perp = np.sum(direction) - direction
        
        particle = 1+np.random.randint(a.particles)
        
        
        site1 = tuple(a.particle_locations[particle] + np.array([0]))
        
        site2 = tuple((site1 + direction)%self.L)
        
        
       # print("SITE1_SITE2_", site1,site2)
        
       
        
        
        #need to make a list of the bonds around each site.
        #this list should work for 1 and 2d (so that I can check still Boltzmann)
        #print("STARTS", self.position,direction)
        #print("direction",direction,self.neighbour_ids[1:])
        site1_env = [self.lattice[tuple((site1+self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[1:]]
        site2_env = [self.lattice[tuple((site2-self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[1:]]
       # print("s1_env",[site1 for direction in self.neighbours[1:]])
       # print("s2_env",[site2 for direction in self.neighbours[1:]])
        #now - we only allow a bond to be changed if all the bonds add up to 0 or 1 (or whatever, but some condition)
        bond_site1_site2 = [self.position[self.lattice[site1],self.lattice[site2]]*np.sign(self.lattice[site1])*np.sign(self.lattice[site2])]
        site1_bonds = [self.position[self.lattice[site1],p]*np.sign(self.lattice[site1])*np.sign(p) for p in site1_env]
        site2_bonds = [self.position[self.lattice[site2],p]*np.sign(self.lattice[site2])*np.sign(p) for p in site2_env]
        
       # print("BS", site1,site2,site1_env,site2_env,self.lattice,bond_site1_site2,site1_bonds,site2_bonds,direction)
       # print(self.position)
       # print(bond_site1_site2+site1_bonds+site2_bonds)
        
        bond_list = bond_site1_site2+site1_bonds+site2_bonds
       # print("BL", bond_list)
        #print(site1,site2,"S1env", site1_env,"S2env", site2_env,self.lattice)
        
        #bond_set = set(list(site1_bonds) + list(site2_bonds) + [list(bond_site1_site2)])
   #     p1b = self.lattice[tuple((site1-direction)%self.L)]
   #     p1u = self.lattice[tuple((site1+perp)%self.L)]
   #     p1d = self.lattice[tuple((site1-perp)%self.L)]
   #     p1 = self.lattice[tuple(site1)]
   #     p2 = self.lattice[tuple(site2)]
   #     p2f = self.lattice[tuple((site2+direction)%self.L)]
   #     p2u = self.lattice[tuple((site2+perp)%self.L)]
   #     p2d = self.lattice[tuple((site2-perp)%self.L)]
        
     #   bond1 = self.position[p1,p2]*np.sign(p1)*np.sign(p2)
        
     #   bond2 = self.position[p1,p1b]*np.sign(p1)*np.sign(p1b)
     #   bond3 = self.position[p2,p2f]*np.sign(p2)*np.sign(p2f)
        
     #   bond4 = self.position[p2,p2u]*np.sign(p2)*np.sign(p2u)
      #  bond5 = self.position[p2,p2d]*np.sign(p2)*np.sign(p2d)
        
      #  bond6 = self.position[p1,p1u]*np.sign(p1)*np.sign(p1u)
      #  bond7 = self.position[p1,p1d]*np.sign(p1)*np.sign(p1d)
        
        #print("HERE", self.counter,bond1,bond2,bond3,bond4,bond5,bond6,bond7)
    #    bond_set = {bond1,bond2,bond3,bond4,bond5,bond6,bond7}
        if self.initial_bonding_position == 1:
            if len(set(bond_list)) != 2:
                return()

            if sum(bond_list) != 1:
                return()
        
        elif self.initial_bonding_position == 0:
            if sum(set(bond_list)) != 0:
                return()
        
    
        #print("HERE")
        old_positions = np.copy(self.position)
        
        
        
        x_new = np.random.choice([0,1],
                                 p=[self.initial_bonding_position==0,
                                    self.initial_bonding_position==1],
                                 size=len(bond_list))
        
        
        #there are three bonds which are broken in 1d Kawasaki
        
       
        
        dE = np.sum(bond_list)
        #print("dE", dE)
        
        #print("GETS HERE", dE, bond_list)
        #print("S1", site1,self.lattice[site1])
        
        p1 = self.lattice[site1]
        p2 = self.lattice[site2]
        
        #print("P1p2", tuple(p1),p2,site1,site2)
        
        self.position[p1,p2] = x_new[0]*np.sign(p1)*np.sign(p2)
        self.position[p2,p1] = self.position[p2,p1]
        
        v = 1
        for p_env in site1_env:
            #reset old to 0, get new
            self.position[p1,p_env] = 0
            self.position[p_env,p1] = 0
            self.position[p2,p_env] = x_new[v]*np.sign(p2)*np.sign(p_env)
            self.position[p_env,p2] = self.position[p2,p_env]
            
            dE -= self.position[p1,p_env]
            dE += self.position[p2,p_env]
            v += 1
            
     
        for p_env in site2_env:
            self.position[p2,p_env] = 0
            self.position[p_env,p2] = 0
            self.position[p1,p_env] = x_new[v]*np.sign(p1)*np.sign(p_env)
            self.position[p_env,p1] = self.position[p1,p_env]
            
            dE -= self.position[p2,p_env]
            dE += self.position[p1,p_env]
            v += 1
        
   
        
        temp = np.copy(self.lattice[tuple(site1)])
        self.lattice[tuple(site1)] = self.lattice[tuple(site2)]
        self.lattice[tuple(site2)] = temp
        
 
        E_after = -(self.E+dE) #self.total_energy()
       # print("Makes", self.E, dE,E_after)
        #print(self.counter,"HERE",E_after,)
      
        
        if np.random.rand() < min(np.exp(-self.beta*(E_after - self.E)),1):
            #print("SWAP", self.counter,p1,p2,site1,site2,self.position[p1,p2])
            self.E = E_after
            self.swaps[self.counter] = 1
            
            #change pairs
            
            #p_i = p1
            
            #print("change pairs",(p2,p1b,p1u,p1d),(p1,p2f,p2u,p2d))
        
            for p_env in site1_env:
                #print("TRYING", p_env,p1)
                self.pairs.discard(tuple(sorted([p1,p_env])))
                if p_env != 0 and p2 != 0:
                    self.pairs.add(tuple(sorted([p2,p_env])))
                
            for p_env in site2_env:
                self.pairs.discard(tuple(sorted([p2,p_env])))
                if p_env != 0:
                    self.pairs.add(tuple(sorted([p1,p_env])))
            
            if p2 != 0:
                self.particle_locations[p2] = site1
            
            self.particle_locations[p1] = site2
            return()

        #reverse the swap and return positions
        temp = np.copy(self.lattice[tuple(site1)])
        self.lattice[tuple(site1)] = self.lattice[tuple(site2)]
        self.lattice[tuple(site2)] = temp
        
        self.position = np.copy(old_positions)
        
    def show(self,bleached=False,plot=True):
        if not bleached:
            if plot:
                plt.imshow(self.lattice != 0)
                return
            else:
                return(self.lattice != 0)
        else:
            #print("SHOWING BLEACHED")
            bl = np.zeros_like(self.lattice)
            for c,v in np.ndenumerate(self.lattice):
                if v not in self.bleached:
                    bl[c] = v
            if plot:
                plt.imshow(bl != 0)
            else:
                return(bl != 0)
        
            
            
        
    def FRAP(self,radius):
        
        self.bleached = set()
        for coord,site in np.ndenumerate(self.lattice):
            
            dist = np.array(coord) - self.L/2
            if np.dot(dist,dist) <= radius**2:
                self.bleached.add(site)
        
     
    
    def iterate(self,iterations=0,snaps=0):
        if snaps != 0:
            every = int(iterations/snaps)
        else:
            every = 1
        t = time.time()
        
        self.pairs = self.get_pairs()
        #print("HERE",self.pairs)
        self.E = self.total_energy()
        self.pair_count[self.counter] = len(self.pairs)
        self.results[self.counter] = self.E
        for iteration in range(0,iterations):
           # print("I",iteration,self.lattice,self.E)
            self.Kawasaki()
            #print("I2",iteration,self.lattice,self.E)
            #
            #for i in range(0,int(self.D)):
            self.update_position()
            if iteration%every==0:
                t2 = time.time()
                #print(self.counter,t2 - t)
                t = t2
                self.results[self.counter] = self.E
                self.pair_count[self.counter] = self.pairs
                self.lattice_snaps[self.counter] = self.draw_energies() # self.show(bleached=True,plot=False)
            self.counter += 1
            
            

import numpy as np
import matplotlib.pyplot as plt
import time
L = 3
a = Kawasaki_Discrete(L=L,dimension=1,beta=1,particles=2,seed = 4,max_x = 3,D=1)
print(a.lattice)
#a.FRAP(10)
#print(a.total_energy())
#print(a.bleached)
a.iterate(iterations = 10000,snaps=0)
print(a.lattice)
#print("pairs",a.pairs)
#print(a.total_energy())
#print(a.results)
#print("pairs",a.pairs)
#print(a.lattice)
#print(a.E)
#plt.plot(a.results.values())
a.compare_Boltzmann()
#a.show(bleached=False,plot=True)

