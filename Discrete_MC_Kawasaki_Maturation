
class Kawasaki_Discrete:
   
    
    def __init__(self,L=5,seed=0,max_x = 0,D=1):
        self.directions = [-1,1]
        np.random.seed(seed)
        self.max_x = max_x
        self.beta= 1
        self.L = L
        self.counter = 0
        self.lattice = np.zeros(self.L,dtype=int)
        self.lattice[0] = 1
        self.lattice[2] = 2
        
        self.unique = len(set(self.lattice).union({0}))
        self.position = np.zeros((self.unique,self.unique),dtype=int)
        self.position[1,2] = 0
        self.position[2,1] = 0
        self.results = dict()
        self.difs = dict()
        self.D = D
        self.neighbours = np.array([-1,1])
        
    
    
    def total_energy(self):
        E = 0
        
        site1,site2 = np.where(self.lattice!=0)[0]
        if (site1+1)%self.L == site2 or  (site2+1)%self.L == site1:
            dif = 1
        else:
            dif = 0
            return(0)
        p1 = self.lattice[site1]
        p2 = self.lattice[site2]
        E = -self.position[p1,p2]*np.sign(p1)*np.sign(p2)
        return(E)
        #gets here, means we just need the 
        
        
        return(-E)
    
    def get_pairs(self):
        pairs = set()
        for i in range(0,len(self.lattice)):
            site = self.lattice[i]
            if site == 0: #no need to consider solvent
                continue
            for n in self.neighbours:
                neighbour = self.lattice[(i+n)%self.L]
                if neighbour != 0:
                
                    pairs.add(tuple(sorted([site,neighbour])))
        
        return(pairs)
    
    def update_position(self):
        pairs = self.get_pairs()
        self.difs[self.counter] = len(pairs)
        if len(pairs) == 0:
            return()
        
        
        #calculate if diffuses or not
        if np.random.rand() > self.D:
            return()
        for pair in pairs:
            p1,p2 = pair
        
            old = np.copy(self.position[p1,p2])
           # new = np.random.randint(self.max_x+1)
            dx = np.random.choice([-1,1])
            new = min(max(old + dx,0),self.max_x)
            self.position[p1,p2] = new
            self.position[p2,p1] = new
            new_E = self.total_energy()
            if np.random.rand() < np.exp(-self.beta*(new_E - self.E)):
                self.E = new_E
            else:
                self.position[p1,p2] = old
                self.position[p2,p1] = old
        return()
        
        
        
    def Kawasaki(self):
        if self.E != 0:
            return()
        #get old stuff copied
        old = np.copy(self.lattice)
        old_positions = np.copy(self.position)
        
        
        
        direction = np.random.choice(self.directions)
        site1 = np.random.choice(np.where(self.lattice != 0)[0])
        site2 = (site1 + direction)%self.L
        #self.E = self.total_energy()
        
        
        
        x_new = np.random.choice([0,1],p=[1,0],size=3)
        
        p1b = self.lattice[(site1-direction)%self.L]
        p1 = self.lattice[site1]
        p2 = self.lattice[site2]
        p2f = self.lattice[(site2+direction)%self.L]
        
        
        #there are three bonds which are broken in 1d Kawasaki
        self.position *= 0
        self.position[p1,p2] = x_new[0]*np.sign(p1)*np.sign(p2)
        self.position[p2,p1] = self.position[p1,p2]

        self.position[p2,p1b] = x_new[1]*np.sign(p2)*np.sign(p1b)
        self.position[p1b,p2] = self.position[p2,p1b]

        self.position[p1,p2f] = x_new[2]*np.sign(p1)*np.sign(p2f)
        self.position[p2f,p1] = self.position[p1,p2f]
        
       
        #now swap the positions on the lattice
        
        temp = np.copy(self.lattice[site1])
        self.lattice[site1] = self.lattice[site2]
        self.lattice[site2] = temp
        
 
        E_after = self.total_energy()
      
        
        if np.random.rand() < min(np.exp(-self.beta*(E_after - self.E)),1):
            self.E = E_after
            return()

        #reverse the swap and return positions
        self.lattice = np.copy(old)
        self.position = np.copy(old_positions)
     
    
    def iterate(self,iterations=0):
        
        #print("HERE",self.lattice)
        #print("BEFORE", self.lattice)
        self.E = self.total_energy()
        self.difs[self.counter] = 0
        self.results[self.counter] = self.E
        for iteration in range(0,iterations):
            
            self.Kawasaki()
            #
            self.update_position()
            self.results[self.counter] = self.E
            self.counter += 1
            
            

import numpy as np
import matplotlib.pyplot as plt
L = 10
a = Kawasaki_Discrete(L=L,seed = 2,max_x = 5,D=1)
a.iterate(10000)
#print(a.lattice)
#print(a.E_values)
#print(a.difs)
plt.plot(a.results.keys(),a.results.values())
plt.scatter(a.results.keys(),a.results.values(),marker='.',c = ['r' if d==1 else 'b' for d in a.difs.values()])
#print(a.position)
#print(a.lattice)
#print(a.results)


energies = list(set(a.results.values()))
import math
occurences = [(i,list(a.results.values()).count(i)) for i in energies]
print(occurences)

sim_results = dict()
theoretical_results = dict()

data = np.array(list(a.results.values()))
#print("d",data)
count = len(data)
arrangements = math.perm(a.L,2)
if a.L > 2:
    degeneracy_unbonded = math.perm(a.L,1)*math.perm(a.L-3,1)
else:
    degeneracy_unbonded = 0
degeneracy_bonded = (arrangements - degeneracy_unbonded)
print("AUB",arrangements,degeneracy_unbonded,degeneracy_bonded)


#bonded is 0 or 1
#unbonded is not all the things that are 0

for x in set(data):
    theoretical_results[x] = degeneracy_bonded*np.exp(-a.beta*x) + (x==0)*degeneracy_unbonded
    
    
theoretical_Z = np.sum(list(theoretical_results.values()))
theoretical_results = dict(zip(theoretical_results.keys(),(1./theoretical_Z)*np.array(list(theoretical_results.values()))))


for x in set(data):
    #print("HERE",x,np.exp(-a.beta*x))
    r = np.sum(data == x)/count
    
    sim_results[x] = r

sim_Z = np.sum(list(sim_results.values()))
sim_results = dict(zip(sim_results.keys(),(1./sim_Z)*np.array(list(sim_results.values()))))
print("ST",sim_results,theoretical_results)
plt.scatter(theoretical_results.values(),sim_results.values())
 #sim_results.keys()))
plt.plot(theoretical_results.values(), theoretical_results.values())
    #print(x,r)

#plt.ylim([0,1])
#plt.xlim([0,1])
