import math
from itertools import compress
from scipy.stats import multinomial
import numpy as np


def moving_average(x, w):
    return np.convolve(x, np.ones(w), 'valid') / w


class Kawasaki_Discrete:
   
    
    def __init__(self,beta=1,dimension=1,particles=2,L=5,seed=0,max_x = 0,D=1,
                min_x = 0,states=None,probs=None,initial_state='gas',dev=0,
                initial_droplet_radius = None,CF_Method = False):
        self.show = True
        self.BM = False
        self.CF_Method = CF_Method
        self.initial_droplet_radius = initial_droplet_radius
        self.initial_state = initial_state
        
        self.directions_dict = dict()
        self.radius = L**2 #big enough so never a prob
        self.bleached = {}
        self.bleach_times = []
        self.bleached=dict()
        self.frame_snaps = dict()
        self.energy_snaps = dict()
        self.bleach_time = 1E9
        self.dimensions = dimension
        np.random.seed(seed)
        self.max_x = max_x
        self.beta= beta
        self.L = L
        self.counter = 0
        self.position_snaps = dict()
        
        self.initial_bonding_position = min_x
        
        self.COM = (self.L/2 + np.array([0,0]))%self.L
        self.rolls = {0:0,1:0}
        self.first_FRAP = True
        
        #we have x positions. Initial, final and the rest equally distributed.
        #solution: make a dictionary that maps the integers to (linearly distb) states
        self.max_states = states
        if self.max_states == 1:
            div = 1
        else:
            div = 1./(self.max_states-1)
        state_J = [self.initial_bonding_position + i*(self.max_x - self.initial_bonding_position)*div for i in range(0,self.max_states)]
        
        self.acceptance_probabilities = [1] + [0]*(self.max_states-1)
        
        
        
        if 0 not in state_J:
            self.acceptance_probabilities = [0] + self.acceptance_probabilities
            state_J = [0] + state_J
            
        
        self.position_energy_map = dict(zip([i for i in range(0,len(state_J))],state_J))
        #print("SJ",self.position_energy_map)
        self.possible_positions = list(self.position_energy_map.keys())
        
         #min_x
        
        if probs == "uniform":
            self.acceptance_probabilities = [0] + [1./(len(self.acceptance_probabilities)-1)]*(len(self.acceptance_probabilities)-1)
        elif probs == "first":
            
            
            self.acceptance_probabilities = [a*0 for a in self.acceptance_probabilities] #[1] + [0]*(self.max_states-1)
            self.acceptance_probabilities[1] = 1
            
        elif probs == "random":
            random_probs = np.random.rand(len(self.acceptance_probabilities))
            if 0 not in state_J:
                random_probs[0] = 0
            self.acceptance_probabilities = random_probs/np.sum(random_probs)
            
            
       # print("SA",self.acceptance_probabilities)
        if self.initial_droplet_radius == None:
            radius_2 = int(particles/np.pi)
            droplet_particles=particles
        else:
            radius_2 = self.initial_droplet_radius**2
            droplet_particles = int(np.pi*radius_2)
            
            
        #first get the radius
        p = 1
        
         
            
        
        self.particles = particles
        
        self.dev = dev
        
        self.J =  -1 + self.dev*np.random.randn(particles+1,particles+1)
        self.J = np.tril(self.J,-1)
        self.J += self.J.T


        #self.FRAP = False
        self.particle_locations = dict()
        
        
        if self.dimensions == 1:
            self.lattice = np.zeros(self.L,dtype=int)
            self.neighbours = [np.array([-1]),np.array([1])]
            self.neighbour_ids = np.array([0,1])
            
            p = 1  
            while p <= particles:

                self.lattice[p-1] = p
                self.particle_locations[p] = p-1
                p += 1
                    
                    
        elif self.dimensions == 2:
            self.lattice = np.zeros((self.L,self.L),dtype=int)
            self.neighbours = [np.array([-1,0]),
                           np.array([0,1]),
                           np.array([1,0]),
                           np.array([0,-1])]
            self.neighbour_ids = np.array([0,1,2,3])
            
            p = 1
            if initial_state != 'gas':
                for coord,site in np.ndenumerate(self.lattice):
                    
                    dist = np.array(coord) -  self.L/2
                    if np.dot(dist,dist) <= radius_2:
                       # print("HERE", coord,site)
                        self.lattice[tuple(coord)] = p
                       # self.particle_locations[p] = tuple(coord)
                        p += 1
                        if p == droplet_particles:
                            break
                    

            x0,y0 = np.where(self.lattice == 0)       
            while p <= particles:
                r = np.random.randint(len(x0))
                if self.lattice[x0[r],y0[r]] == 0:
                    self.lattice[x0[r],y0[r]] = p
                   # self.particle_locations[p] = tuple(coord)
                    p += 1
            
            #now translate everything
            
            initial_coord = np.array([0,0])
            self.lattice = np.roll(np.roll(self.lattice,initial_coord[0],axis=0),initial_coord[1],axis=1)
            
            for coord,site in np.ndenumerate(self.lattice):
                if site != 0:
                    self.particle_locations[site] = tuple(coord)
            
            
            
        else:
            print("ERROR - DIMENSION NOT SUPPORTED")
            return()
        
        
        
        
        
        
        
        
        
        self.unique = 1 + particles
        self.position = np.zeros((self.unique,self.unique),dtype=int)
        self.frame = np.zeros(self.unique,dtype=object)
        self.frame = dict(zip([p for p in range(0,self.unique)],[np.array([0]*self.dimensions) for p in range(0,self.unique)]))
        
        
        #frame is updated if a swap happens which crosses the boundary
        #direction
        
        pairs = self.get_pairs()
        for pair in pairs:
            p1,p2 = pair
            if probs == 'uniform':
                #generate a random position
                position = np.random.choice(self.possible_positions[1:])
            else:
                position = self.initial_bonding_position
            self.position[p1,p2] = position #self.max_x
            self.position[p2,p1] = position  #self.max_x 
            
        #print("GIVES")
        self.position_snaps[0] = self.position
        #print(self.position)
        self.results = dict()
        self.pair_count = dict()
        self.D = D
        self.swaps = dict()
        
        self.lattice_snaps = dict()
        self.lattice_snaps[0] = self.lattice
        self.E = self.total_energy()
        
        
        
    def compare_Boltzmann(self):
        import matplotlib.pyplot as plt
        #two situations - one where bond starts at 1 and one where starts at 0
        
        energies = list(set(self.results.values()))
        
        occurences = [(i,energies.count(i)) for i in energies]
        

        sim_results = dict()
        theoretical_results = dict()

        data = np.array(list(self.results.values()))
        count = len(data)
        arrangements = math.perm(self.L,2)
        if self.L > 2:
            degeneracy_unbonded = math.perm(self.L,1)*math.perm(self.L-3,1)
        else:
            degeneracy_unbonded = 0
        degeneracy_bonded = (arrangements - degeneracy_unbonded)
        if self.show:
            print("AUB",arrangements,degeneracy_unbonded,degeneracy_bonded)
        
            
       # print("HERE", set(list(self.position_energy_map.values())))
     #   print("HERE", set(data))
        energy_values = list([-s for s in self.position_energy_map.values()])  # set(data).union(to_add)
        #print("EV",energy_values)
        if degeneracy_unbonded > 0:
            if 0 not in energy_values:
                energy_values += [0]
        unique, counts = np.unique(energy_values, return_counts=True)
        energy_counts = dict(zip(unique, counts)) #this contains the degeneracy of each energy
      #  print("THERE",energy_values)
        #bonded is 0 or 1
        #unbonded is not all the things that are 0

        for x,count in energy_counts.items():
            #x = energy_values[i]
            if self.show:
                print("x=",x,(x >=  self.position_energy_map[self.initial_bonding_position]),degeneracy_bonded,np.exp(-self.beta*x),(x==0)*degeneracy_unbonded)
            
            #what I mean is - if initial_bonding position is 0,
            #we include all energies. Otherwise, the 0 energy one only
            #contributes to unbonded
            if self.initial_bonding_position == 0:
                theoretical_results[x] = count*(degeneracy_bonded*np.exp(-self.beta*x) + (x==0)*degeneracy_unbonded)
            else:
                theoretical_results[x] = count*((x != 0)*degeneracy_bonded*np.exp(-self.beta*x) + (x==0)*degeneracy_unbonded)
                
                
           
            
            
                


        theoretical_Z = np.sum(list(theoretical_results.values()))
        theoretical_results = dict(zip(theoretical_results.keys(),(1./theoretical_Z)*np.array(list(theoretical_results.values()))))


        for x in energy_values:
            
            r = np.sum(data == x)/count

            sim_results[x] = r
            
            
            
        import matplotlib as mpl
        import matplotlib.pylab as pl
        cmap = pl.cm.Blues_r
        cmaplist = [cmap(i) for i in range(cmap.N)]

        # create the new map
        cmap = mpl.colors.LinearSegmentedColormap.from_list(
            'Custom cmap', cmaplist, cmap.N)
        

        sim_Z = np.sum(list(sim_results.values()))
        sim_results = dict(zip(sim_results.keys(),(1./sim_Z)*np.array(list(sim_results.values()))))
        
        if not self.show:
            return(sim_results,theoretical_results)
        print("ST",sim_results,theoretical_results)
        
        xvals = np.array(sorted(set(energy_values))[::-1])
        
        #plt.plot(sorted(list(theoretical_results.values())), sorted(list(theoretical_results.values())),ls='dashed',c='black')
        pl.plot([0,1],[0,1],ls='dashed',c='black')
        #for E in energy_values:
         #   plt.text(theoretical_results[E], sim_results[E],str(int(-E)) + '$\\beta$')
        pl.xlabel("Boltzmann Prediction")
        pl.ylabel("Simulation Results")
      #  plt.legend(["E = " + str(int(E)) + '$\\beta$' for E in sorted(energy_values)[::-1]])
        pl.gca().set_aspect('equal')
        
        
        #  xvals = np.linspace(0,5,6)
        # define the bins and normalize
        bounds = np.linspace(-len(xvals),0 , len(xvals)+1)
        norm = mpl.colors.BoundaryNorm(bounds, cmap.N)

        #print(bounds)
        
        
        for E in xvals:
            
           # plt.scatter(theoretical_results[E],sim_results[E],s=100) #,c='black')
            
            pl.scatter(theoretical_results[E],sim_results[E],c=E-1,cmap=cmap,norm=norm,edgecolor='black',s=200)
         #sim_results.keys()))
        
        
        
        
      

        
        ax2 = pl.gcf().add_axes([0.95, 0.1, 0.03, 0.8])
        cb = mpl.colorbar.ColorbarBase(ax2, cmap=cmap, norm=norm,
            spacing='proportional', ticks=bounds, boundaries=bounds, format='%1i')

        ax2.set_yticks(xvals - 0.5, minor=False)
        cb.ax.set_yticklabels([str(int(E)) + '$ \\beta $' for E in xvals])
        
        
        
        #----
        
        
    def draw_energies(self):
        pairs = set()
        for coord,site in np.ndenumerate(self.lattice): #range(0,len(self.lattice)):
            
            #site = self.lattice[i]
            if site == 0: #no need to consider solvent
                continue
            for n in self.neighbours:
                n_coord = (np.array(coord)+n)%self.L
                neighbour = self.lattice[tuple(n_coord)]
                #print("HERE",self.counter,(np.array(coord)+n)%self.L)
                if neighbour != 0:

                    pairs.add((tuple(sorted([site,neighbour])),coord))
        E_matrix = np.zeros((self.L,self.L))
        for info in pairs:
           # print("HERE",info)
            p1,p2 = info[0]
            coord = info[1]
            E = -self.J[p1,p2]*self.position_energy_map[self.position[p1,p2]]*np.sign(p1)*np.sign(p2)
            
            E_matrix[tuple(coord)] += E
        return(E_matrix)
    
    def total_energy(self):
        E = 0
        pairs = self.get_pairs()
        
        for pair in pairs:
            p1,p2 = pair
        
            E += self.J[p1,p2]*self.position_energy_map[self.position[p1,p2]]*np.sign(p1)*np.sign(p2)
        
            
        return(E)
        #gets here, means we just need the 
        
        
        return(-E)
    
    def get_pairs(self):
        pairs = set()
        for coord,site in np.ndenumerate(self.lattice): #range(0,len(self.lattice)):
            
            #site = self.lattice[i]
            if site == 0: #no need to consider solvent
                continue
            for n in self.neighbours:
                n_coord = (np.array(coord)+n)%self.L
                neighbour = self.lattice[tuple(n_coord)]
                #print("HERE",self.counter,(np.array(coord)+n)%self.L)
                if neighbour != 0:
                    
                    pairs.add(tuple(sorted([site,neighbour])))
        
        return(pairs)
    
    def update_position(self):
        
        if len(self.pairs) == 0:
            return()
        
        
        #calculate if diffuses or not
     #   if np.random.rand() > self.D:
     #       return()
        
        pair = list(self.pairs)[np.random.randint(len(self.pairs))]
        p1,p2 = pair

        old = np.copy(self.position[p1,p2])
        old_bond_E = self.J[p1,p2]*self.position_energy_map[self.position[p1,p2]]
       # new = np.random.randint(self.max_x+1)
        dx = np.random.choice([-1,1])
        
        if self.CF_Method:
            dx = np.abs(dx) #can only increase
    
    
        new = min(max(old + dx,self.initial_bonding_position),self.initial_bonding_position+self.max_states-1)
        
        
        
   #     new = np.random.choice(np.array(list(set(list(self.position_energy_map.keys())) - {0})))
        
        self.position[p1,p2] = new
        self.position[p2,p1] = new
        new_bond_E = self.J[p1,p2]*self.position_energy_map[self.position[p1,p2]]
        
       
        new_E = self.E - old_bond_E + new_bond_E # self.total_energy()
       # new_E = self.total_energy()
        
        if np.random.rand() < np.exp(-self.beta*(new_E - self.E)):
            self.E = new_E
        else:
            self.position[p1,p2] = old
            self.position[p2,p1] = old
        return()
        
        
        
    def Kawasaki(self):
        
        
        #a big speed up perhaps? Not really
        
        
        self.swaps[self.counter] = 0
        
        #get old stuff copied
        
        #shuffle neighbour ids and pick the first one. Use the rest for site 1. Mirror them (* -1 ) for site 2
        np.random.shuffle(self.neighbour_ids)
        
        direction_id = self.neighbour_ids[0]
        self.directions_dict[self.counter] = np.zeros(2)
        
        
        #if self.BM:
            
            #self.directions_dict[self.counter] = self.neighbours[direction_id]
            #return()
        
        
        
        
      
        
        particle = 1+np.random.randint(self.particles)
        
        
        site1 = tuple(self.particle_locations[particle] + np.array([0]))
        
        if self.local:
            direction = self.neighbours[direction_id]
            adjacent_coordinate = site1 + direction
            PBC_adjacent_coordinate = adjacent_coordinate%self.L
            site2 = tuple(PBC_adjacent_coordinate)
            
            reverse_direction = direction = (direction_id+2)%4
            
        else:
            #make sure big enough
            if self.L -2 <= 2:
                return()
            direction = np.random.randint(2,self.L-1,size=self.dimensions)
            adjacent_coordinate = site1 + direction
            PBC_adjacent_coordinate = adjacent_coordinate%self.L
            
            site2 = tuple(PBC_adjacent_coordinate)
        

        other_particle = self.lattice[site2]
        
        
        if self.mode == "ps":
            #then since we only allow particle-solvent swaps, we need to make sure site 2 is solvent
            #note this would get FRAP wrong but might speed up initial condensation
            if self.lattice[site2] != 0:
                return()
        
        #determine whether it's particle-particle interaction
        
        
        
        if self.local:
            site1_env = [self.lattice[tuple((site1+self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[1:]]
            site2_env = [self.lattice[tuple((site2-self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[1:]]
        else:
            #consider all bonds
            site1_env = [self.lattice[tuple((site1+self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[0:]]
            site2_env = [self.lattice[tuple((site2-self.neighbours[n_id])%self.L)] for n_id in self.neighbour_ids[0:]]
            
        
   
        site1_bonds = [int(self.position[self.lattice[site1],p]) for p in site1_env]
        site2_bonds = [int(self.position[self.lattice[site2],p]) for p in site2_env]
        
        #site1_energies = [self.J[self.lattice[site1],p]*int(self.position[self.lattice[site1],p]) for p in site1_env]
        #site2_energies = [self.J[self.lattice[site2],p]*int(self.position[self.lattice[site2],p]) for p in site2_env]
        
        pp_interaction = [np.sign(self.lattice[site1])*np.sign(p) for p in site1_env] + [np.sign(self.lattice[site2])*np.sign(p) for p in site2_env]
        pp_interaction_bool = [bool(p) for p in pp_interaction]
        
        #print(self.counter,"pp_interaction_bool",self.lattice[site1],self.lattice[site2],site1_env,site2_env,site1_bonds,site2_bonds,pp_interaction_bool)
        
    
        
        bond_list = site1_bonds+site2_bonds
        bond_E = [self.J[self.lattice[site1],p] for p in site1_env] + [self.J[self.lattice[site2],p] for p in site2_env]
        #print("BC", bond_E)
        #bond_energies_list = 
        
        
        
        pp_bonds = list(compress(bond_list, pp_interaction_bool))
        pp_E = list(compress(bond_E, pp_interaction_bool))
        #print("GIVES", self.counter,pp_bonds,pp_E)
        
        outcome_count = [pp_bonds.count(v) for v in self.possible_positions]
        
        p = multinomial.pmf(outcome_count, n=len(pp_bonds), p=self.acceptance_probabilities)
        #print(self.position)
        #print(self.counter,"OC",outcome_count,"p",p,pp_bonds,pp_E)
        if p < np.random.rand():
            #print("ERROR!")
            if not self.CF_Method:
                
                return() #to obey detailed balance!
        
        #the positions that will be altered: site1:site1_env and 
        
        #old_positions = np.copy(self.position)
        
        
        
        x_new = np.random.choice(self.possible_positions,len(bond_list),p=self.acceptance_probabilities)
        
        dE = np.sum([-E*self.position_energy_map[p] for p,E in zip(pp_bonds,pp_E)])
        #print("NEW", pp_bonds,dE,site1_env,site2_env)
       
        p1 = self.lattice[site1]
        p2 = self.lattice[site2]
        
  
        v = 0
        for p_env in site1_env:
            #reset old to 0, get new
            self.position[p1,p_env] = 0
            self.position[p_env,p1] = 0
        for p_env in site2_env:
            self.position[p2,p_env] = 0
            self.position[p_env,p2] = 0
            
        for p_env in site1_env:
            self.position[p2,p_env] = x_new[v]*np.sign(p2)*np.sign(p_env)
            self.position[p_env,p2] = self.position[p2,p_env]
            
            
            dE += self.J[p2,p_env]*self.position_energy_map[self.position[p2,p_env]]*np.sign(p2)*np.sign(p_env)
            v += 1
       
        
        for p_env in site2_env:
            self.position[p1,p_env] = x_new[v]*np.sign(p1)*np.sign(p_env)
            self.position[p_env,p1] = self.position[p1,p_env]
            #print("ADDING", p1,p_env,)
            
            dE += self.J[p1,p_env]*self.position_energy_map[self.position[p1,p_env]]*np.sign(p1)*np.sign(p_env)
            v += 1
        
        temp = np.copy(self.lattice[tuple(site1)])
        self.lattice[tuple(site1)] = self.lattice[tuple(site2)]
        self.lattice[tuple(site2)] = temp
        
        E_after = (self.E+dE)
        
        #E_after = self.total_energy()
        #print("COMP",self.counter,self.E+dE, E_after)
       
       # print("S1S2", site1,site2,direction,E_after,self.E)
        
        if np.random.rand() < min(np.exp(-self.beta*(E_after - self.E)),1):
            #if particle == 1:
            self.directions_dict[self.counter] = self.neighbours[direction_id] #at equilibrium so all particles count
            self.all_directions_dict[particle][self.counter] = direction_id+1
            self.all_directions_dict[other_particle][self.counter] = reverse_direction + 1
            #swap occurs
            self.E = E_after
            self.swaps[self.counter] = 1
            
         
        
            for p_env in site1_env:
                
                self.pairs.discard(tuple(sorted([p1,p_env])))
                if p_env != 0 and p2 != 0:
                    self.pairs.add(tuple(sorted([p2,p_env])))
                
            for p_env in site2_env:
                self.pairs.discard(tuple(sorted([p2,p_env])))
                if p_env != 0:
                    self.pairs.add(tuple(sorted([p1,p_env])))
            
            if p2 != 0:
                self.particle_locations[p2] = site1
            
            self.particle_locations[p1] = site2
            
            #lastly update the frame
            if self.local:
                if not np.array_equal(adjacent_coordinate,PBC_adjacent_coordinate):


                    self.frame[p1] += direction
                    #print("HERE",adjacent_coordinate,PBC_adjacent_coordinate,direction,self.frame)
                    if p2 != 0:
                        self.frame[p2] -= direction
                    
                
                
                
            return()

        #reverse the swap and return positions
        
        temp = np.copy(self.lattice[tuple(site1)])
        self.lattice[tuple(site1)] = self.lattice[tuple(site2)]
        self.lattice[tuple(site2)] = temp
        
        #print("BEFORE", self.position)
        
        for p,old_p in zip(site1_env,site1_bonds):
            self.position[self.lattice[site1],p] = int(old_p)
            self.position[p,self.lattice[site1]] = int(old_p)
        for p,old_p in zip(site2_env,site2_bonds):
            self.position[self.lattice[site2],p] = int(old_p)
            self.position[p,self.lattice[site2]] = int(old_p)
            
        #print("NOW", self.position)
       # site1_bonds = [np.copy(self.position[self.lattice[site1],p]) for p in site1_env]
        #site2_bonds = [np.copy(self.position[self.lattice[site2],p]) for p in site2_env]
        
        #self.position = old_positions
        
    def show(self,bleached=False,plot=True):
        if not bleached:
            if plot:
                plt.imshow(self.lattice != 0)
                return
            else:
                return(self.lattice != 0)
        else:
            
            bl = np.zeros_like(self.lattice)
            for c,v in np.ndenumerate(self.lattice):
                if v not in self.bleached:
                    bl[c] = v
            if plot:
                plt.imshow(bl != 0)
            else:
                return(bl != 0)
        
    def get_COM(self):
        L = self.L
        test_lattice = self.lattice
        COM = np.array([0.,0.])
        
        rolls = dict()
        for axis in [0,1]:
            possible_particle_coordinates = {i:np.array(np.where(np.roll(test_lattice,i,axis=axis) != 0)).T for i in range(0,L)}

            possible_COMS = {i:np.sum(p,axis=0)/len(p) for i,p in possible_particle_coordinates.items()}

            possible_arc_lengths = {i:np.sum([np.dot(z,z) for z in possible_COMS[i]-possible_particle_coordinates[i]]) for i in possible_particle_coordinates.keys()}

            best = min(possible_arc_lengths, key = possible_arc_lengths.get)
            rolls[axis] = best
            self.rolls = rolls
            COM[axis] = (possible_COMS[best][axis])%self.L
            #print("a",axis,)
            
        
        self.COM = COM
        #print("COM", self.COM)
            
        
    def FRAP(self,radius):
        
        if self.first_FRAP:
            self.first_FRAP = False
            self.get_COM()

            #now roll the lattice and positions

            self.lattice = np.roll(np.roll(self.lattice,self.rolls[0],axis=0),self.rolls[1],axis=1)

            for coord,site in np.ndenumerate(self.lattice):
                    if site != 0:
                        self.particle_locations[site] = tuple(coord)

            #also flip all previous things 

            for k,l in self.lattice_snaps.items():

                self.lattice_snaps[k] = np.roll(np.roll(self.lattice_snaps[k],self.rolls[0],axis=0),self.rolls[1],axis=1)
                self.energy_snaps[k] = np.roll(np.roll(self.energy_snaps[k],self.rolls[0],axis=0),self.rolls[1],axis=1)
            
            
            
            
        
        bleach_time = self.counter
        self.bleach_time = bleach_time
        self.bleach_times.append(bleach_time)
        self.bleached[bleach_time] = set()
        self.radius = radius
        for coord,site in np.ndenumerate(self.lattice):
            
            delta = coord - self.COM
            a_delta = np.abs(delta)
            dist = np.array([x if 2*ax < self.L else -np.sign(x)*(self.L - ax) for x,ax in zip(delta,a_delta)])
            
            #dist = np.minimum(np.array(coord) - self.COM)
            #need to account for PBC
            
            if np.dot(dist,dist) <= radius**2:
                self.bleached[bleach_time].add(site)
        self.lattice_snaps[self.counter] = self.lattice
        self.frame_snaps[self.counter] = {k: np.array(v) for k, v in self.frame.items()}
        
    def history(self,bleached=False):
        self.to_print = dict()
        #import matplotlib.pyplot as plt
        #print(self.lattice_snaps.keys())
        rows = 1 + len(self.bleach_times)
        #fig,axs = plt.subplots(1 + len(self.bleach_times),len(self.lattice_snaps.keys()))
        #fig.set_size_inches(20.5, 5.5)
        #fig.suptitle('$\\beta$ = ' + str(self.beta)+', L = ' + str(self.L) + ', D = ' + str(self.D) + ', t = ' + str(self.counter) + ', $J_{min} = $' + str(self.initial_bonding_position) + ', $J_{max} = $' + str(self.max_x)+', states = ' + str(self.max_states), fontsize=16)
        for b in range(0,len(self.bleach_times)):
            bleach_time = self.bleach_times[b]
            for i,k in zip(range(0,len(list(self.lattice_snaps.keys()))),list(self.lattice_snaps.keys())):
                #print("ik",i,k,k >= self.bleach_time)
                l = self.lattice_snaps[k] #np.roll(np.roll(,self.rolls[0],axis=0),self.rolls[1],axis=1) #/(4*self.max_x)
                if bleached and k >= bleach_time:

                    bl = np.zeros_like(l)
                    for c,v in np.ndenumerate(l):
                        if v not in self.bleached[bleach_time]:
                            bl[c] = v
                        else:

                            frame_dist = self.frame_snaps[k][v] - self.frame_snaps[bleach_time][v]
                            #print("HERE",c,v,frame_dist,self.bleached)
                            if np.dot(frame_dist,frame_dist) != 0:
                                bl[c] = v   
                else:
                    bl = l
                #axs[b][i].set_title(k)
                
                self.to_print[(b,i,k)] = (bl == 0) + 0
             #   axs[b][i].matshow(((bl == 0) + 0),vmin=0,vmax=1,cmap='Greys')
             #   axs[b][i].set_axis_off()
                #Erolled = np.roll(np.roll(self.energy_snaps[k],self.rolls[0],axis=0),self.rolls[1],axis=1)
            for i,k in zip(range(0,len(list(self.lattice_snaps.keys()))),list(self.lattice_snaps.keys())):
                #axs[len(self.bleach_times)][i].imshow(-self.energy_snaps[k]/(4*self.max_x),vmin=0,vmax=1)
                self.to_print[(len(self.bleach_times),i,k)] = -self.energy_snaps[k]/(4*self.max_x)
           #     axs[len(self.bleach_times)][i].set_axis_off()
    def plot_FRAP_recovery(self):
        #get the amount of fluorescence in the radius
        #
        self.flu_data = dict()
        for bleach_time in self.bleach_times:
            self.flu = dict(zip(list(self.lattice_snaps.keys()),[0 for j in list(self.lattice_snaps.keys())]))
            for k in list(self.lattice_snaps.keys()):
                #l = self.lattice_snaps[k]
                l = self.lattice_snaps[k] #np.roll(np.roll(,self.rolls[0],axis=0),self.rolls[1],axis=1)
                for coord,site in np.ndenumerate(l):

                    dist = np.array(coord) - self.COM
                    if np.dot(dist,dist) <= self.radius**2:
                        #then it's inside.

                        if site != 0: #make sure it's a particle
                            if k < bleach_time:
                                self.flu[k] += 1
                            else:
                                if site not in self.bleached[bleach_time]: #check whether it got bleached
                                    self.flu[k] += 1
                                else:
                                    #print("INSIDE", coord,site)
                                    frame_dist = self.frame_snaps[k][site] - self.frame_snaps[bleach_time][site]
                                    if np.dot(frame_dist,frame_dist) != 0:
                                        self.flu[k] += 1
            
            #print(self.flu)
            self.flu_data[bleach_time] = self.flu
        return(self.flu_data)
                
        
     
    
    def iterate(self,iterations=0,snaps=0,mode=None,anneal=False,local=True):
        
        #prev_loc = self.
        if snaps > 1:
            every = int(iterations/(snaps-1))
        elif snaps == 1:
            every = iterations
        else:
            every = 1
        
        self.mode = mode
        self.pairs = self.get_pairs()
        
        self.all_directions_dict = np.zeros((self.particles+1,iterations+1),dtype=int)
        D_base = int(np.floor(self.D))
        print("print",D_base,self.D)
        self.E = self.total_energy()
        self.pair_count[self.counter] = len(self.pairs)
        self.results[self.counter] = self.E
        for iteration in range(0,iterations+1):
            if anneal:
                self.beta = iteration/iterations
            if not local:
                self.local = False #np.random.choice([True,False])
            else:
                self.local = True
            
            if iteration%every==0:
                
                self.results[self.counter] = self.E
                self.pair_count[self.counter] = self.pairs
                self.lattice_snaps[self.counter] = np.copy(self.lattice) 
                self.energy_snaps[self.counter] = self.draw_energies()
                self.frame_snaps[self.counter] = {k: np.array(v) for k, v in self.frame.items()}
                self.position_snaps[self.counter] = np.copy(self.position)
            self.swaps[self.counter] = 0
            self.Kawasaki()
            #for i in range(0,50):
            
            
            #decide whether to update position by d
            for i in range(0,D_base):
                self.update_position()
                
            r = np.random.rand()
            
            if r < (self.D - D_base):
                self.update_position()
            
            #print("U",self.E,self.lattice)
            
            if iteration == iterations:
                return()
            self.counter += 1
        #self.counter -= 1
            
  


